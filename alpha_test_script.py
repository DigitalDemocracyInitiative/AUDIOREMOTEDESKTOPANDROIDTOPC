# alpha_test_script.py
#
# Purpose:
# This script serves as an alpha test harness for the PC client application (`script.py`).
# It is designed to programmatically launch the client, simulate a period of interaction
# (or allow it to run for a fixed duration), capture its console output (stdout and stderr),
# and then terminate the client. This facilitates automated or semi-automated testing.
#
# Key Functionalities to be Included:
# 1. Launching the `script.py` (PC client) as a separate process.
# 2. Simulating user interaction by letting the client run for a specified duration.
# 3. Capturing and printing/logging the stdout and stderr from the client process.
# 4. Programmatically terminating the client process.
# 5. (Conceptual) Defining test points or checks based on expected log output or behavior.

import subprocess
import time
import sys # To use the same Python interpreter for the client script
import pyaudio # For audio simulation
import wave    # For WAV file handling
import numpy as np # For generating sine wave
import os      # For checking hypothetical file existence

# --- Test Configuration Constants ---
CONNECTION_WAIT_TIME = 10  # seconds, to wait for client to potentially connect
TEST_DURATION = 15         # seconds, to simulate client running time
TERMINATE_TIMEOUT = 5      # seconds, timeout for process.terminate()
COMMUNICATE_TIMEOUT = 5    # seconds, timeout for process.communicate()

# --- Constants for Generated WAV File (Played by this script as input) ---
TEST_AUDIO_FILENAME = "temp_test_audio.wav" # Input WAV generated by this script
TEST_AUDIO_DURATION = 2.0  # seconds
TEST_AUDIO_FREQUENCY = 440.0 # Hz (A4 note)
TEST_AUDIO_RATE = 44100
TEST_AUDIO_CHANNELS = 1
TEST_AUDIO_FORMAT = pyaudio.paInt16

try:
    p_temp_audio_init = pyaudio.PyAudio()
    TEST_AUDIO_SAMPLE_WIDTH = p_temp_audio_init.get_sample_size(TEST_AUDIO_FORMAT)
    p_temp_audio_init.terminate()
except Exception as e_audio_init:
    print(f"ERROR_TEST_SCRIPT: Could not determine PyAudio sample width. Defaulting to 2. Error: {e_audio_init}")
    TEST_AUDIO_SAMPLE_WIDTH = 2 # paInt16 is 2 bytes

# --- Constants for Audio Saved by PC Client (script.py) ---
TEMP_RECEIVED_AUDIO_FILENAME = "temp_received_audio.wav" # Output WAV saved by script.py
RECEIVED_AUDIO_SAVE_DURATION = 3 # seconds for script.py to save

# --- Constant for matching client's log output ---
CLIENT_LOG_PREFIX_FROM_SCRIPT = "CLIENT_LOG:"

# --- Audio Simulation and Test Verification Functions ---
def simulate_audio_input():
    # Note: This function plays audio through the system's default output.
    # For script.py (PC client) to pick this up as microphone input,
    # a system audio loopback utility (e.g., VB-Cable, LoopBeAudio, Soundflower, or OS-level routing)
    # must be configured to route this output to the client's microphone input device.
    # This script does NOT handle that system-level audio routing.
    print(f"INFO_TEST_SCRIPT: Preparing to simulate audio input by generating and playing {TEST_AUDIO_FILENAME}...")
    p_sim = None; wf_write_sim = None; wf_read_sim = None; stream_out_sim = None
    try:
        p_sim = pyaudio.PyAudio(); num_samples = int(TEST_AUDIO_DURATION * TEST_AUDIO_RATE)
        t = np.linspace(0, TEST_AUDIO_DURATION, num_samples, endpoint=False)
        sine_wave = 0.5 * np.sin(2 * np.pi * TEST_AUDIO_FREQUENCY * t)
        audio_data_int = (sine_wave * 32767).astype(np.int16); audio_bytes = audio_data_int.tobytes()
        wf_write_sim = wave.open(TEST_AUDIO_FILENAME, 'wb'); wf_write_sim.setnchannels(TEST_AUDIO_CHANNELS)
        wf_write_sim.setsampwidth(TEST_AUDIO_SAMPLE_WIDTH); wf_write_sim.setframerate(TEST_AUDIO_RATE)
        wf_write_sim.writeframes(audio_bytes); wf_write_sim.close(); wf_write_sim = None
        print(f"INFO_TEST_SCRIPT: Generated {TEST_AUDIO_FILENAME} for audio simulation.")
        wf_read_sim = wave.open(TEST_AUDIO_FILENAME, 'rb')
        stream_out_sim = p_sim.open(format=p_sim.get_format_from_width(wf_read_sim.getsampwidth()),
                                channels=wf_read_sim.getnchannels(), rate=wf_read_sim.getframerate(), output=True)
        print(f"INFO_TEST_SCRIPT: Playing {TEST_AUDIO_FILENAME} through default output...")
        chunk_size = 1024; data_frames = wf_read_sim.readframes(chunk_size)
        while len(data_frames) > 0: stream_out_sim.write(data_frames); data_frames = wf_read_sim.readframes(chunk_size)
        print(f"INFO_TEST_SCRIPT: Finished playing {TEST_AUDIO_FILENAME}.")
    except Exception as e: print(f"ERROR_TEST_SCRIPT: Failed to simulate audio input: {e}")
    finally:
        if wf_write_sim: wf_write_sim.close()
        if wf_read_sim: wf_read_sim.close()
        if stream_out_sim:
            if stream_out_sim.is_active(): stream_out_sim.stop_stream()
            stream_out_sim.close()
        if p_sim: p_sim.terminate()
        print("INFO_TEST_SCRIPT: Audio simulation resources cleaned up.")

def verify_test_results(stdout_logs, stderr_logs):
    global CLIENT_LOG_PREFIX_FROM_SCRIPT, RECEIVED_AUDIO_SAVE_DURATION, TEMP_RECEIVED_AUDIO_FILENAME
    global TEST_AUDIO_RATE, TEST_AUDIO_CHANNELS, TEST_AUDIO_SAMPLE_WIDTH

    print("\nINFO_TEST_SCRIPT: --- Test Verification Start ---")
    overall_test_passed = True

    print("INFO_TEST_SCRIPT: --- Log Analysis ---")
    log_analysis_passed = True

    required_success_patterns = [
        f"{CLIENT_LOG_PREFIX_FROM_SCRIPT} [STATUS] WebSocket connection established.",
        f"{CLIENT_LOG_PREFIX_FROM_SCRIPT} [STATUS] Microphone stream opened successfully.",
        f"{CLIENT_LOG_PREFIX_FROM_SCRIPT} [STATUS] Speaker stream opened for received audio.",
        f"{CLIENT_LOG_PREFIX_FROM_SCRIPT} [INFO] Successfully saved ~{RECEIVED_AUDIO_SAVE_DURATION}s of received audio to {TEMP_RECEIVED_AUDIO_FILENAME}"
    ]
    critical_error_patterns = [
        f"{CLIENT_LOG_PREFIX_FROM_SCRIPT} [ERROR]",
        "Traceback (most recent call last):"
    ]

    print("INFO_TEST_SCRIPT: Verifying required success patterns in STDOUT...")
    if stdout_logs:
        for pattern in required_success_patterns:
            if pattern in stdout_logs:
                print(f"INFO_TEST_SCRIPT: [PASS] Required success log FOUND: '{pattern}'")
            else:
                print(f"INFO_TEST_SCRIPT: [FAIL] Required success log NOT FOUND: '{pattern}'")
                log_analysis_passed = False
    else:
        print("INFO_TEST_SCRIPT: [FAIL] Client STDOUT was empty. Required success logs not found.")
        log_analysis_passed = False

    print("INFO_TEST_SCRIPT: Verifying critical error patterns in STDOUT and STDERR...")
    for pattern in critical_error_patterns:
        if stdout_logs and pattern in stdout_logs:
            print(f"INFO_TEST_SCRIPT: [FAIL] Critical error pattern FOUND in STDOUT: '{pattern}'")
            log_analysis_passed = False
        if stderr_logs and pattern in stderr_logs:
            print(f"INFO_TEST_SCRIPT: [FAIL] Critical error pattern FOUND in STDERR: '{pattern}'")
            log_analysis_passed = False

    if not stderr_logs:
        print("INFO_TEST_SCRIPT: [PASS] STDERR from client was empty.")
    else:
        is_stderr_error_already_found = any(pattern in stderr_logs for pattern in critical_error_patterns)
        if not is_stderr_error_already_found and stderr_logs.strip():
            print(f"INFO_TEST_SCRIPT: [WARN] STDERR from client was NOT empty and contained messages not matching critical error patterns (review manually):\n---\n{stderr_logs[:300]}...\n---")

    if not log_analysis_passed:
        overall_test_passed = False
    print("INFO_TEST_SCRIPT: --- Log Analysis Complete ---")

    print("\nINFO_TEST_SCRIPT: --- Audio File Analysis ---")
    audio_file_analysis_passed = True

    if not os.path.exists(TEMP_RECEIVED_AUDIO_FILENAME):
        print(f"INFO_TEST_SCRIPT: [FAIL] Saved audio file NOT FOUND: '{TEMP_RECEIVED_AUDIO_FILENAME}'")
        audio_file_analysis_passed = False
    elif overall_test_passed :
        try:
            with wave.open(TEMP_RECEIVED_AUDIO_FILENAME, 'rb') as wf:
                n_channels_rec = wf.getnchannels()
                sampwidth_rec = wf.getsampwidth()
                framerate_rec = wf.getframerate()
                n_frames_rec = wf.getnframes()
                expected_channels = TEST_AUDIO_CHANNELS
                expected_sampwidth = TEST_AUDIO_SAMPLE_WIDTH
                expected_framerate = TEST_AUDIO_RATE
                duration_seconds = n_frames_rec / float(framerate_rec)
                duration_tolerance = 0.5
                expected_saved_duration = float(RECEIVED_AUDIO_SAVE_DURATION)
                print(f"INFO_TEST_SCRIPT: Analyzing '{TEMP_RECEIVED_AUDIO_FILENAME}': Channels={n_channels_rec}, Rate={framerate_rec}, SampleWidth={sampwidth_rec}, Frames={n_frames_rec}, Duration={duration_seconds:.2f}s")
                if n_channels_rec != expected_channels:
                    print(f"INFO_TEST_SCRIPT: [FAIL] Audio channels mismatch. Expected {expected_channels}, Got {n_channels_rec}")
                    audio_file_analysis_passed = False
                else: print(f"INFO_TEST_SCRIPT: [PASS] Audio channels match expected ({expected_channels}).")
                if sampwidth_rec != expected_sampwidth:
                    print(f"INFO_TEST_SCRIPT: [FAIL] Audio sample width mismatch. Expected {expected_sampwidth} bytes, Got {sampwidth_rec} bytes")
                    audio_file_analysis_passed = False
                else: print(f"INFO_TEST_SCRIPT: [PASS] Audio sample width matches expected ({expected_sampwidth} bytes).")
                if framerate_rec != expected_framerate:
                    print(f"INFO_TEST_SCRIPT: [FAIL] Audio framerate mismatch. Expected {expected_framerate} Hz, Got {framerate_rec} Hz")
                    audio_file_analysis_passed = False
                else: print(f"INFO_TEST_SCRIPT: [PASS] Audio framerate matches expected ({expected_framerate} Hz).")
                if not (expected_saved_duration - duration_tolerance <= duration_seconds <= expected_saved_duration + duration_tolerance):
                    print(f"INFO_TEST_SCRIPT: [FAIL] Saved audio duration mismatch. Expected ~{expected_saved_duration}s, Got {duration_seconds:.2f}s")
                    audio_file_analysis_passed = False
                else: print(f"INFO_TEST_SCRIPT: [PASS] Saved audio duration is approximately correct ({duration_seconds:.2f}s).")
                if n_frames_rec > 0 :
                    frames = wf.readframes(n_frames_rec)
                    if sampwidth_rec == 2 and n_channels_rec == 1:
                        audio_data_int = np.frombuffer(frames, dtype=np.int16)
                        rms_amplitude = np.sqrt(np.mean(audio_data_int.astype(np.float64)**2))
                        silence_threshold = 100
                        print(f"INFO_TEST_SCRIPT: Calculated RMS amplitude of received audio: {rms_amplitude:.2f}")
                        if rms_amplitude < silence_threshold: print(f"INFO_TEST_SCRIPT: [WARN] Received audio content may be silent or very quiet (RMS: {rms_amplitude:.2f}).")
                        else: print(f"INFO_TEST_SCRIPT: [PASS] Received audio content is not silent (RMS: {rms_amplitude:.2f}).")
                    else: print(f"INFO_TEST_SCRIPT: [INFO] RMS check skipped: Unsupported audio format for simple RMS (Channels: {n_channels_rec}, Sampwidth: {sampwidth_rec} bytes).")
                else: print(f"INFO_TEST_SCRIPT: [WARN] Saved audio file has no frames. Cannot check for silence.")
        except wave.Error as e_wave:
            print(f"INFO_TEST_SCRIPT: [FAIL] Error opening/reading WAV file '{TEMP_RECEIVED_AUDIO_FILENAME}': {e_wave}")
            audio_file_analysis_passed = False
        except Exception as e_audio_analysis:
            print(f"INFO_TEST_SCRIPT: [FAIL] Unexpected error during audio file analysis: {e_audio_analysis}")
            audio_file_analysis_passed = False
        if os.path.exists(TEMP_RECEIVED_AUDIO_FILENAME):
            try:
                os.remove(TEMP_RECEIVED_AUDIO_FILENAME)
                print(f"INFO_TEST_SCRIPT: Cleaned up (deleted) {TEMP_RECEIVED_AUDIO_FILENAME}.")
            except Exception as e_remove: print(f"INFO_TEST_SCRIPT: [WARN] Could not remove {TEMP_RECEIVED_AUDIO_FILENAME}: {e_remove}")
    elif not overall_test_passed:
         print(f"INFO_TEST_SCRIPT: Skipping audio file analysis for '{TEMP_RECEIVED_AUDIO_FILENAME}' due to prior log failures.")
    if not audio_file_analysis_passed: overall_test_passed = False
    print("INFO_TEST_SCRIPT: --- Audio File Analysis Complete ---")
    return overall_test_passed

if __name__ == "__main__":
    CLIENT_SCRIPT_PATH = "script.py"
    command = [
        sys.executable, CLIENT_SCRIPT_PATH,
        "--auto-start",
        "--save-received-audio", TEMP_RECEIVED_AUDIO_FILENAME,
        "--save-duration", str(RECEIVED_AUDIO_SAVE_DURATION)
    ]
    print("INFO_TEST_SCRIPT: Initializing test script...")
    print(f"INFO_TEST_SCRIPT: Client launch command: {' '.join(command)}")
    client_process = None
    final_test_passed_status = False # Initialize to False, only set to True if all checks pass

    try:
        print("INFO_TEST_SCRIPT: Starting PC client process (script.py)...")
        client_process = subprocess.Popen(
            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)
        print(f"INFO_TEST_SCRIPT: PC client process started with PID: {client_process.pid}")
        print(f"INFO_TEST_SCRIPT: Waiting {CONNECTION_WAIT_TIME}s for client to initialize/connect...")
        time.sleep(CONNECTION_WAIT_TIME)
        print("INFO_TEST_SCRIPT: Attempting to simulate audio input...")
        simulate_audio_input()
        print("INFO_TEST_SCRIPT: Audio input simulation step complete.")
        min_run_time = RECEIVED_AUDIO_SAVE_DURATION + TEST_AUDIO_DURATION + 5
        effective_test_duration = max(TEST_DURATION, min_run_time)
        print(f"INFO_TEST_SCRIPT: Main test activity duration: Allowing client to run for {effective_test_duration}s...")
        time.sleep(effective_test_duration)
        print("INFO_TEST_SCRIPT: Main test activity duration complete.")
        print("INFO_TEST_SCRIPT: Attempting to terminate PC client process...")
        if client_process.poll() is None:
            client_process.terminate()
            try: client_process.wait(timeout=TERMINATE_TIMEOUT)
            except subprocess.TimeoutExpired:
                print(f"INFO_TEST_SCRIPT: Client process did not terminate gracefully within {TERMINATE_TIMEOUT}s, killing...")
                client_process.kill()
                try: client_process.wait(timeout=TERMINATE_TIMEOUT)
                except subprocess.TimeoutExpired: print("INFO_TEST_SCRIPT: Client process failed to die even after kill.")
            print("INFO_TEST_SCRIPT: PC client process termination attempt finished.")
        else: print("INFO_TEST_SCRIPT: Client process already terminated before explicit termination attempt.")
        print("INFO_TEST_SCRIPT: Capturing final stdout/stderr from PC client...")
        stdout_output, stderr_output = "", ""
        try:
            stdout_output, stderr_output = client_process.communicate(timeout=COMMUNICATE_TIMEOUT)
            print("INFO_TEST_SCRIPT: Log capture via communicate() successful.")
        except subprocess.TimeoutExpired:
            print(f"INFO_TEST_SCRIPT: Timeout during final log capture with communicate(timeout={COMMUNICATE_TIMEOUT}).")
            if client_process.poll() is None: client_process.kill()
            try: stdout_output, stderr_output = client_process.communicate(timeout=1)
            except: pass
        print("INFO_TEST_SCRIPT: Log capture complete.")
        print("\n--- Client STDOUT ---"); print(stdout_output if stdout_output else "<No stdout captured>"); print("--- End Client STDOUT ---\n")
        print("--- Client STDERR ---"); print(stderr_output if stderr_output else "<No stderr captured>"); print("--- End Client STDERR ---\n")
        if client_process.returncode is None: client_process.poll()
        print(f"INFO_TEST_SCRIPT: Client exited with return code: {client_process.returncode}")
        print("INFO_TEST_SCRIPT: Starting test results verification...")
        final_test_passed_status = verify_test_results(stdout_output, stderr_output)
        print("INFO_TEST_SCRIPT: Test results verification complete.")
    except FileNotFoundError:
        print(f"INFO_TEST_SCRIPT: Error - Client script '{CLIENT_SCRIPT_PATH}' not found.")
        final_test_passed_status = False
    except Exception as e:
        print(f"INFO_TEST_SCRIPT: Error during test script execution: {e}")
        final_test_passed_status = False
        if client_process and client_process.poll() is None:
            print("INFO_TEST_SCRIPT: Test script error. Killing client..."); client_process.kill()
            try: client_process.wait(timeout=TERMINATE_TIMEOUT)
            except subprocess.TimeoutExpired: print("INFO_TEST_SCRIPT: Client kill after test error timed out.")
    finally:
        if client_process and hasattr(client_process, 'pid') and client_process.poll() is None:
            print("INFO_TEST_SCRIPT: Test script ending. Final client kill check."); client_process.kill()
            try: client_process.wait(timeout=TERMINATE_TIMEOUT)
            except subprocess.TimeoutExpired: print(f"INFO_TEST_SCRIPT: Client PID {client_process.pid} sticky on final kill.")

        # Cleanup for TEST_AUDIO_FILENAME (Input WAV generated by this script)
        if os.path.exists(TEST_AUDIO_FILENAME):
            try:
                os.remove(TEST_AUDIO_FILENAME)
                print(f"INFO_TEST_SCRIPT: Cleaned up (deleted) input WAV file: {TEST_AUDIO_FILENAME}.")
            except Exception as e_remove_input:
                print(f"INFO_TEST_SCRIPT: [WARN] Could not remove input WAV file {TEST_AUDIO_FILENAME}: {e_remove_input}")

        # --- Overall Test Result ---
        print("\nINFO_TEST_SCRIPT: --- Overall Test Result ---")
        if final_test_passed_status:
            print("INFO_TEST_SCRIPT: **** ALPHA TEST PASSED ****")
        else:
            print("INFO_TEST_SCRIPT: **** ALPHA TEST FAILED ****")

    print("\nINFO_TEST_SCRIPT: Test script execution finished.")
